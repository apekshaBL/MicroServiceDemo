spring.application.name=auth-service
server.port=8089

# --- Database Configuration ---
spring.datasource.url=jdbc:postgresql://${DB_HOST:localhost}:${DB_PORT:5432}/student_service_db
spring.datasource.username=postgres
spring.datasource.password=piyush8547
spring.datasource.driver-class-name=org.postgresql.Driver

# --- Liquibase Configuration ---
# CRITICAL: Set to FALSE.
# We disabled this because 'DatabaseInitializer.java' now runs the migration
# manually for 'engineering', 'physics', etc.
spring.liquibase.enabled=false
# Correct path matches your screenshot (master.xml)
spring.liquibase.change-log=classpath:db/changelog/master.xml

# --- JPA / Hibernate Multi-Tenancy ---
# CRITICAL: Set to NONE. Let Liquibase handle the tables.
# If you leave this as 'update', Hibernate might fight with Liquibase.
spring.jpa.hibernate.ddl-auto=none
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect

# --- ENABLE MULTI-TENANCY (UNCOMMENTED) ---
# 1. Tell Hibernate to use the SCHEMA strategy
spring.jpa.properties.hibernate.multiTenancy=SCHEMA

# 2. Register your Connection Provider (The class that does 'SET search_path')
spring.jpa.properties.hibernate.multi_tenant_connection_provider=auth_service.common.config.MultiTenantConnectionProviderImpl

# 3. Register your Resolver (The class that asks 'Which tenant?')
spring.jpa.properties.hibernate.tenant_identifier_resolver=auth_service.common.config.TenantIdentifierResolver


# --- Consul Discovery ---
spring.cloud.consul.discovery.health-check-critical-timeout=1m
spring.cloud.consul.discovery.instance-id=${spring.application.name}:${random.value}
spring.cloud.consul.discovery.prefer-ip-address=true
spring.cloud.consul.discovery.hostname=127.0.0.1
spring.jpa.open-in-view=false